<?php
/**
 * \file
 * Define the abstract Register class.
 * \author Oscar van Eijk, Oveas Functionality Provider
 * \copyright{2007-2011} Oscar van Eijk, Oveas Functionality Provider
 * \license
 * This file is part of Terra-Terra.
 *
 * Terra-Terra is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * Terra-Terra is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Terra-Terra. If not, see http://www.gnu.org/licenses/.
 */


/**
 * \name Status code bitmaps
 * These bitmaps define the layout of status codes. They are used to extract information from the code
 * @{
 */

/**
 * Bits 1-12 define the developer.
 * Developer code must be between 0x0 and 0x1EE. The developer code 0x1EF is for Oveas.
 * When passed to the registerApp() method, the code  will be shifted to match the pattern.
 */
define ('TT_DEVELOPER_PATTERN',		0xfff0000000000000);

/**
 * Bits 13-28 define the application. The code is maintained by the developer.
 * When passed to the registerApp() method, the code  will be shifted to match the pattern.
 */
define ('TT_APPLICATION_PATTERN',	0x000ffff000000000);

/**
 * Bits 29-44 define the object type of an application.
 * This is generated by registerClass() when the application is loaded.
 */
define ('TT_OBJECT_PATTERN',		0x0000000ffff00000);

/**
 * Bits 45-60 defines the (object specific) status code. This is generated by 
 */
define ('TT_STATUS_PATTERN',		0x00000000000ffff0);

/**
 * Bits 61-64 define the severity
 */
define ('TT_SEVERITY_PATTERN',		0x000000000000000f);

/**
 * @}
 */

/**
 * TT keeps track of all running applications, their class and all status codes
 * their instances (objects) can have.
 * This is done in a global Register, which is maintained by this class.
 * \ingroup TT_SO_LAYER
 * \author Oscar van Eijk, Oveas Functionality Provider
 * \version May 15, 2007 -- O van Eijk -- initial version
 */
abstract class Register
{
	static private $currentApp = '';

	/**
	 * Initialise the register array
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function init()
	{

		$_mtime = microtime(true);
		if (strpos($_mtime, '.') === false) {
			$_mtime .= '.0';
		}

		list ($_s, $_m) = explode ('.', $_mtime);
		$_s = sprintf ('%X', $_s);
		$_m = sprintf ('%X', $_m);
		// Set the applications run ID
		TTCache::set(TTCACHE_REGISTER, 'run', array('id'	=> "$_s$_m", 'tcp' => ''));
		
		TTCache::set(TTCACHE_REGISTER, 'applications', array());
		TTCache::set(TTCACHE_REGISTER, 'classes', array());
		TTCache::set(TTCACHE_REGISTER, 'severity', array());
		TTCache::set(TTCACHE_REGISTER, 'codes', array());
		TTCache::set(TTCACHE_REGISTER, 'code_symbols', array());
		TTCache::set(TTCACHE_REGISTER, 'stack', array());
	}

	/**
	 * Bitshift a value to the given value is placed at the position given by the the pattern.
	 * E.g.:
	 * \code{.php}
	 * self::valueShift(0x5bf, 0x0fff0000);
	 * // returns: 0x05bf0000
	 * \endcode
	 * \param[in] $value A (hexa)decimal value
	 * \param[in] $pattern Bitpattern in hexadecimal format with only 0's and f's (basically, any of the TT_*_PATTERN constants)
	 * \return Shifter value.
	 */
	static private function valueShift($value, $pattern)
	{
		$_pattern = decbin($pattern);
		preg_match('/(1*)(0*)/i', $_pattern, $_matches);
		if ($value > bindec($_matches[1])) {
			$_msg = sprintf("Overflow - value %d is too large for pattern %%X016X)",
					$value, $pattern);
			die ($_msg);
		}

		return ($value << strlen($_matches[2]));
	}

	/**
	 * Point to the current app that's registering classes
	 * \param[in] $app App name
	 */
	static private function setCurrentApp($app)
	{
		self::$currentApp = $app;
	}

	/**
	 * Get the name of the class that's currenlty registering classes
	 * \return App name
	 */
	static private function getCurrentApp()
	{
		return self::$currentApp;

	}

	/**
	 * Reset the current appname. Called by TTLoader after a class or interface is fully loaded.
	 */
	static public function resetCurrentApp()
	{
		self::$currentApp = '';
		
	}

	/**
	 * Store the specified application in the register
	 * \param[in] $applicationName Name of the application
	 * \param[in] $developerId Developer ID. This is a 3 byte code between 0x000 and 0x1ef. Code 0x1ef is reserved for Oveas.
	 * \param[in] $applicationId Application ID. This is a  byte code: 0x0000 - 0xffff
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function registerApp ($applicationName, $developerId, $applicationId)
	{
		//		printf("Register %s, class now %%X%016X<br>", $applicationName, $applicationId);
		if ($applicationId <= 0 || $applicationId > 0x1ef) {
			$_msg = sprintf("Access violation - ID for application %s (%d) is out of range",
					$applicationName, $applicationId);
			die ($_msg);
		}

		$_devId = self::valueShift($developerId, TT_DEVELOPER_PATTERN);
		$_appId = self::valueShift($applicationId, TT_APPLICATION_PATTERN);
		$_id = $_devId + $_appId;

		// use isset() here, since array_key_exists() gives a warning if the hex $id
		// has a negative integer value.
		// To make sure the ID is not interpreted as an index, cast it as a string
		$_apps =& TTCache::getRef(TTCACHE_REGISTER, 'applications');
		if (!isset ($_apps["$_id"])) {
			$_apps["$_id"] = $applicationName;
		}
		if (!isset ($_apps[$applicationName])) {
			$_apps[$applicationName] = array('class' => $_id);
		}
		self::setApplication ($_id);
	}

	/**
	 * Register a new interface. Currently, this is only used to set the current appname.
	 * This method /must/ be called when an interface defines statuscodes.
	 * \param[in] $name Name of the interface --- currently ignored
	 * \param[in] $appName Name of the application to which this interface belongs
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function registerInterface ($name, $appName)
	{
		self::setCurrentApp($appName);
	}

	/**
	 * Store the specified class in the register, and setup an array to keep track of the codes
	 * \param[in] $name Name of the class
	 * \param[in] $appName Name of the application to which this class belongs
	 * \todo Error handling when out of range
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function registerClass ($name, $appName)
	{
		$_apps =& TTCache::getRef(TTCACHE_REGISTER, 'applications');
		$_apps[$appName]['class'] += self::valueShift(1, TT_OBJECT_PATTERN);
		$id = $_apps[$appName]['class'];
//		printf("Class %s gets %%X%016X (%d)<br>", $name, $_apps['class'], $_apps['class']);
		// use isset() here, since array_key_exists() gives a warning if the hex $id
		// has a negative integer value.
		// To make sure the ID is not interpreted as an index, cast it as a string
		$_classes =& TTCache::getRef(TTCACHE_REGISTER, 'classes');
		if (!isset ($_classes["$id"])) {
			$_classes["$id"] = $name;
			$_codes =& TTCache::getRef(TTCACHE_REGISTER, 'codes');
			$_codes["$id"] = array();
		} else {
			// TODO; should we generate a warning here?
		}
		self::setCurrentApp($appName);
	}

	/**
	 * Define a new statuscode
	 * \param[in] $code Symbolic name of the status code
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function registerCode ($code)
	{
		if (defined ($code)) {
			// TODO; should we generate a warning here?
		}

		$_stack =& TTCache::getRef(TTCACHE_REGISTER, 'stack');		
		if (!array_key_exists ('severity', $_stack)) {
			die ("Fatal error - Register::registerCode($code) called without a current severity; call Register::setSeverity() first");
		}
		$_apps =& TTCache::getRef(TTCACHE_REGISTER, 'applications');
		if (!array_key_exists(self::getCurrentApp(), $_apps)) {
			die ("Fatal error - Register::registerCode($code) called without a current application/class; call Register::registerClass() first");
		}

		// Some pointers for readability and initialise non-existing arrays
		$_class = $_apps[self::getCurrentApp()]['class'];

		// Cast the $_class ID below to a string to make sure it's not interpreted as an index
		$_codeReg =& TTCache::getRef(TTCACHE_REGISTER, 'codes');
		
		$_codes =& $_codeReg["$_class"];
		$_sev = $_stack['severity'];

		if (!isset($_codes[$_sev])) {
			$_codes[$_sev] = 0x0;
		}
		$_codes[$_sev] += self::valueShift(1, TT_STATUS_PATTERN);

		$_value = $_class | $_codes[$_sev] | $_sev;
//		printf ("<tt><span style=\"display:block; float:left; width:300px;\">Code for %s</span>: %d (%%X%016X) | %d (%%X%016X) | %d (%%X%016X) : %%X%016X</tt><br/>", $code, $_class,$_class, $_codes[$_sev],$_codes[$_sev], $_sev,$_sev, $_value);
		define ($code, $_value);
		$_symbols =& TTCache::getRef(TTCACHE_REGISTER, 'code_symbols');
		$_symbols["$_value"] = $code;
	}

	/**
	 * Store the known severitylevels in the register
	 * \param[in] $level Symbolic name for the severity level
	 * \param[in] $name Human readable value
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function registerSeverity ($level, $name)
	{
		$_severity =& TTCache::getRef(TTCACHE_REGISTER, 'severity');
		$_severity['name']["$level"] = $name; // Cast as a string!
		$_severity['value']['TT_' . $name] = $level;
	}

	/**
	 * Read a severity level from the register
	 * \param[in] $level Hex value of the severity level
	 * \return Human readable value
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function getSeverity ($level)
	{
		$_severity = TTCache::get(TTCACHE_REGISTER, 'severity');
		if (!array_key_exists ("$level", $_severity['name'])) {
			return ('(unspecified)');
		} else {
			return ($_severity['name']["$level"]);
		}
	}

	/**
	 * This function is used by a config parse to translate a string value to
	 * the appropriate severity level
	 * \param[in] $name The name of the severity level
	 * \return Hex value of the severity level
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function getSeverityLevel ($name)
	{
		$_severity = TTCache::get(TTCACHE_REGISTER, 'severity');
		if (!array_key_exists ("$name", $_severity['value'])) {
			return (-1);
		} else {
			return ($_severity['value'][$name]);
		}
	}

	/**
	 * Return the ID of the current run
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function getRunId ()
	{
		$_id = TTCache::get(TTCACHE_REGISTER, 'run');
		return ($_id['id']);
	}

	/**
	 * Translate an hex value code to the symbolic name
	 * \param[in] $value Hex value of the status code
	 * \param[in] $unknown Return value if the code does not exist
	 * \return Human readable value
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function getCode ($value, $unknown = '*unknown*')
	{
		$_symbols = TTCache::get(TTCACHE_REGISTER, 'code_symbols');
		if (!array_key_exists ("$value", $_symbols)) {
			return ($unknown);
		} else {
			return ($_symbols["$value"]);
		}
	}


	/**
	 * Point the register to the specified application.
	 * \param[in] $app_id Application ID
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function setApplication ($app_id)
	{
		$_stack =& TTCache::getRef(TTCACHE_REGISTER, 'stack');
		$_stack['app'] = $app_id;
	}

	/**
	 * Point the register to the specified class.
	 * \param[in] $class_id Class ID
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function setClass ($class_id)
	{
		$_stack =& TTCache::getRef(TTCACHE_REGISTER, 'stack');
		$_stack['class'] = $class_id;
	}

	/**
	 * Set the current severity to the specified level in the Register
	 * \param[in] $severity_level Severity level
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function setSeverity ($severity_level)
	{
		$_stack =& TTCache::getRef(TTCACHE_REGISTER, 'stack');
		$_stack['severity'] = $severity_level;
	}

	/**
	 * Load the message file for TT and the application
	 * \param[in] $_force Boolean to force a reload with (different) translations, defaults to false
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function registerMessages ($_force = false)
	{
		$_lang = ConfigHandler::get ('locale', 'lang');
		$_msgs =& TTCache::getRef(TTCACHE_LOCALE, 'messages');
		if (TTCache::get(TTCACHE_MSGFILES, 'ttMessages') === null) {
			if (file_exists (TT_LIBRARY . '/tt.messages.' . $_lang . '.php')) {
				require (TT_LIBRARY . '/tt.messages.' . $_lang . '.php');
				$_found = TTCache::set(TTCACHE_MSGFILES, 'ttMessages', true);
			} elseif (file_exists (TT_LIBRARY . '/tt.messages.php')) {
				require (TT_LIBRARY . '/tt.messages.php');
				$_found = TTCache::set(TTCACHE_MSGFILES, 'ttMessages', true);
			} else {
				$_found = TTCache::set(TTCACHE_MSGFILES, 'ttMessages', false);
			}
			if ($_found === true) {
				$_msgs = $_msgs + $_messages;
			}
		}

		if (TTCache::get(TTCACHE_MSGFILES, strtolower(TTloader::getCurrentAppCode()) . 'Messages') === null) {
			if (file_exists (TTloader::getCurrentAppLib() . '/' . strtolower(TTloader::getCurrentAppCode()) . '.messages.' . $_lang . '.php')) {
				require (TTloader::getCurrentAppLib() . '/' . strtolower(TTloader::getCurrentAppCode()) . '.messages.' . $_lang . '.php');
				$_found = TTCache::set(TTCACHE_MSGFILES, strtolower(TTloader::getCurrentAppCode()) . 'Messages', true);
			} elseif (file_exists (TTloader::getCurrentAppLib() . '/' . strtolower(TTloader::getCurrentAppCode()) . '.messages.php')){
				require (TTloader::getCurrentAppLib() . '/' . strtolower(TTloader::getCurrentAppCode()) . '.messages.php');
				$_found = TTCache::set(TTCACHE_MSGFILES, strtolower(TTloader::getCurrentAppCode()) . 'Messages', true);
			} else {
				$_found = TTCache::set(TTCACHE_MSGFILES, strtolower(TTloader::getCurrentAppCode()) . 'Messages', false);
			}
			if ($_found === true) {
				$_msgs = $_msgs + $_messages;
			}
		}
	}

	/**
	 * Load the labels file for Terra-Terra or the application
	 * \param[in] $_tt When true, the Terra-Terra file(s) will be loaded, by default only the application's
	 * \author Oscar van Eijk, Oveas Functionality Provider
	 */
	static public function registerLabels ($_tt = false)
	{
		$_lang = ConfigHandler::get ('locale', 'lang');
		$_lbls =& TTCache::getRef(TTCACHE_LOCALE, 'labels');

		// Suppress 'Undefined constants' notices for codes not (yet) registered
		if ($_tt) {
			if (TTCache::get(TTCACHE_LBLFILES, 'ttLabels') === null) {
				if (file_exists (TT_LIBRARY . '/tt.labels.' . $_lang . '.php')) {
					require (TT_LIBRARY . '/tt.labels.' . $_lang . '.php');
					$_found = TTCache::set(TTCACHE_LBLFILES, 'ttLabels', true);
				} elseif (file_exists (TT_LIBRARY . '/tt.labels.php')) {
					require (TT_LIBRARY . '/tt.labels.php');
					$_found = TTCache::set(TTCACHE_LBLFILES, 'ttLabels', true);
				} else {
					$_found = TTCache::set(TTCACHE_LBLFILES, 'ttLabels', false);
				}
				if ($_found === true) {
					$_lbls = $_lbls + $_labels;
				}
			}
		} else {
			if (TTCache::get(TTCACHE_LBLFILES, strtolower(TTloader::getCurrentAppCode()) . 'Labels') === null) {
				if (file_exists (TTloader::getCurrentAppLib() . '/' . strtolower(TTloader::getCurrentAppCode()) . '.labels.' . $_lang . '.php')) {
					require (TTloader::getCurrentAppLib() . '/' . strtolower(TTloader::getCurrentAppCode()) . '.labels.' . $_lang . '.php');
					$_found = TTCache::set(TTCACHE_LBLFILES, strtolower(TTloader::getCurrentAppCode()) . 'Labels', true);
				} elseif (file_exists (TTloader::getCurrentAppLib() . '/' . strtolower(TTloader::getCurrentAppCode()) . '.labels.php')) {
					require (TTloader::getCurrentAppLib() . '/' . strtolower(TTloader::getCurrentAppCode()) . '.labels.php');
					$_found = TTCache::set(TTCACHE_LBLFILES, strtolower(TTloader::getCurrentAppCode()) . 'Labels', true);
				} else {
					$_found = TTCache::set(TTCACHE_LBLFILES, strtolower(TTloader::getCurrentAppCode()) . 'Labels', false);
				}
				if ($_found === true) {
					$_lbls = $_lbls + $_labels;
				}
			}
		}
	}
}

Register::init();
