#!/usr/bin/perl
#
# This simple conversion script reads an SQL file as generated by MySQL Workbench
# and writes an SQL file for use with Oracle databases.
#
# Usage:
# ------
#   mysql2oracle.pl < mysql_input.sql > oracle_output.sql
#
# Tested with:
# ------------
#   * Input scripts from MySQL Workbench 5.2.34
#   * Output script tested on Oracle 10g and 11g
#
# NOTES:
# ------
#   * This script has not been tested with different formatting of the input
#   * Manual created files 'might work'(tm) if:
#     - all SQL is in uppercase
#     - all tablenames are enclosed by backticks
#     - all column definitions are written on 1 line, 1 definition per line
#   * The output is not formatted for readability or optimized in any way
#
# TODO:
# -----
#   * The MySQL 'SET()' datatype is not supported
#   * The 'ON UPDATE CASCADE' constraint on foreign keys is not supported
#   * Foreign keys can only refer to primary keys, *not* unique indexes
#   * Oracle also supports comments, but the syntax is not support by this script.
#
# Conversions made:
#   * Remove DROP TABLE statements
#   * Remove all MySQL SET statements
#   * Remove all commentlines
#   * Seperate CREATE INDEX command
#   * Remove 'NULL' as opposite of 'NOT NULL'
#   * Remove 'NOT NULL' for AUTO_INCREMENT fields and fields with a DEFAULT
#   * Remove all COMMENT[ = ] statements
#   * Remove the ENGINE specification
#   * Replace ENUM() by CHECK constraints
#   * Replace AUTO_INCREMENT by a sequence+trigger
#   * Remove all backticks (or replace with quotes) and database names
#   * Remove 'IF NOT EXISTS' from the 'CREATE TABLE' statements
#   * Remove 'ON UPDATE [...]' from the foreign keys
#   * Remove 'ON DELETE' in foreign key constraints NO ACTION and RESTRICT (different syntax but default behaviour)
#   * Add a DROP TABLE statement after a tables was created as a VIEW placeholder
#   * Add a tablespace
# 
# Author:
# -------
# Oscar van Eijk, InTraffic
#
# History:
# --------
# v0.0.0.0-000000001, Sep 12, 2011 - Initial version
# v0.0.0.0-000000002, Sep 22, 2011 - Added the $main::oracleQuotes config option
#
use strict;

$main::thisScript = 'mysql2oracle.pl';
$main::thisVersion = '0.0.0.0-000000002';



$main::tblSpace = 'dacota'; # Tablespace name in Oracle
$main::mysqlScheme = 'Dacota'; # MySQL scheme name
$main::oracleQuotes = '"'; # Replacement for the MySQL backticks

# This hash holds all MySQL datatypes and their Oracle alternatives
# (See http://download.oracle.com/docs/cd/E12151_01/doc.150/e12155/oracle_mysql_compared.htm)
#
%main::rTypes = (
	 'BIGINT' => 'NUMBER(19, 0)'
	,'BIT' => 'RAW'
	,'DATETIME' => 'DATE'
	,'DECIMAL' => 'FLOAT(24)'
	,'DOUBLE' => 'FLOAT(24)'
	,'DOUBLE PRECISION' => 'FLOAT(24)'
	,'INT' => 'NUMBER(10, 0)'
	,'INTEGER' => 'NUMBER(10, 0)'
	,'LONGBLOB' => 'BLOB'
	,'LONGTEXT' => 'CLOB'
	,'MEDIUMBLOB' => 'BLOB'
	,'MEDIUMINT' => 'NUMBER(7, 0)'
	,'MEDIUMTEXT' => 'CLOB'
	,'NUMERIC' => 'NUMBER'
	,'REAL' => 'FLOAT(24)'
	,'SMALLINT' => 'NUMBER(5, 0)'
	,'TEXT' => 'CLOB'
	,'TIME' => 'DATE'
	,'TIMESTAMP' => 'DATE'
	,'TINYBLOB' => 'RAW'
	,'TINYINT' => 'NUMBER(3, 0)'
	,'TINYTEXT' => 'VARCHAR2(255)'
	,'VARCHAR' => 'VARCHAR2'
	,'VARBINARY(\d*?)' => 'BLOB'
	,'YEAR' => 'NUMBER'
);

# Oracle does not support Auto Increment fields.
# This can be simulated by adding a sequence and a trigger for
# each Auto Increment field
#
# Parameters:
#   $tbl    String  Tablename
#   $col    String  Name of the column
#
# Return:
#   string  Sql statement to create the sequence and trigger
#
sub addAutoInc($$)
{
	my ($tbl, $col) = @_;
	my $seq = $col . '_seq';
	my $trg = $tbl . '_trg';

	if (length($col) > 28) {
		$seq = substr ($col, 0, 28) . '_seq';
	}
	if (length($tbl) > 28) {
		$trg = substr ($tbl, 0, 28) . '_seq';
	}
	
	return "CREATE SEQUENCE $main::oracleQuotes$seq$main::oracleQuotes \n"
		. "    START WITH 1\n"
		. "    INCREMENT BY 1\n"
		. ";\n"
		. "CREATE TRIGGER $main::oracleQuotes$trg$main::oracleQuotes\n"
		. "    BEFORE INSERT ON $main::oracleQuotes$tbl$main::oracleQuotes\n"
		. "FOR EACH ROW\n"
		. "DECLARE\n"
		. "    max_id NUMBER;\n"
		. "    cur_seq NUMBER;\n"
		. "BEGIN\n"
		. "    IF :new.$main::oracleQuotes$col$main::oracleQuotes IS NULL THEN\n"
		. "        SELECT $main::oracleQuotes$seq$main::oracleQuotes.NEXTVAL\n"
		. "            INTO :new.$main::oracleQuotes$col$main::oracleQuotes\n"
		. "            FROM DUAL\n"
		. "        ;\n"
		. "    ELSE\n"
		. "        SELECT GREATEST(NVL(MAX($main::oracleQuotes$col$main::oracleQuotes),0), :new.$main::oracleQuotes$col$main::oracleQuotes)\n"
		. "            INTO max_id FROM $main::oracleQuotes$tbl$main::oracleQuotes\n"
		. "        ;\n"
		. "        SELECT $main::oracleQuotes$seq$main::oracleQuotes.NEXTVAL\n"
		. "            INTO cur_seq\n"
		. "            FROM DUAL\n"
		. "        ;\n"
		. "        WHILE cur_seq < max_id\n"
		. "        LOOP\n"
		. "            SELECT $main::oracleQuotes$seq$main::oracleQuotes.NEXTVAL\n"
		. "               INTO cur_seq\n"
		. "               FROM DUAL\n"
		. "            ;\n"
		. "        END LOOP;\n"
		. "    end if;\n"
		. "end;\n"
		. "/\n";
}

# This constaint is added to simulate the MySQL ENUM() type in Oracle
#
# Parameters:
#   $tbl    String  Tablename
#   $col    String  Name of the column
#   $vals   String  Comma separated list with values, enclosed by parentheses
#   $mSize  Integer Reference to the integer holding the longest stringsize
#
# Return:
#   string  Sql statement to create the constraint
#
sub addConstraint($$$$)
{
	my ($tbl, $col, $vals, $mSize) = @_;
	my $ctr = $col . '_constr';
	if (length($col) > 25) {
		$ctr = substr ($col, 0, 25) . '_constr';
	}
	$$mSize = 0;
	my @values = split (/\s*,\s*/, $vals);
	foreach (@values) {
		if ((my $len = length($_)-2) > $$mSize) {
			$$mSize = $len;
		}
	}
	return "ALTER TABLE $main::oracleQuotes$tbl$main::oracleQuotes\n"
		. "    ADD CONSTRAINT $main::oracleQuotes$ctr$main::oracleQuotes\n"
		. "    CHECK ($main::oracleQuotes$col$main::oracleQuotes IN ($vals))"
		. ";\n";
}

# Although Oracle supports index definitions within the CREATE TABLE
# statement, it's easier to use a seperate CREATE [UNIQUE] INDEX statement
# in this conversion script
#
# Parameters:
#   $tbl    String  Tablename
#   $idx    String  Name of the index
#   $cols   String  Comma separated list with column names, enclosed by parentheses
#   $unique Boolean True when an unique index must be created
#
# Return:
#   string  Sql statement to create the index
#
sub addIndex($$$$)
{
	my ($tbl, $idx, $cols, $unique) = @_;
	if (length($idx) > 32) {
		$idx = substr ($idx, 0, 32);
	}
	return 'CREATE ' . ($unique ? 'UNIQUE ' : '') .  "INDEX $main::oracleQuotes$idx$main::oracleQuotes \n"
		. "    ON $main::oracleQuotes$tbl$main::oracleQuotes $cols\n"
		. ";\n";
}

# Go through the hash with datatypes and replace all MySQL types
# with their Oracla alternatives
#
# Parameters:
#   $ln     String  Input line which is a part of the sql statement
#
# Return:
#   string  Input line with replaced typenames
#
sub replaceTypes ($)
{
	my $ln = shift;
	foreach my $k (keys %main::rTypes) {
		$ln =~ s/(\W)$k(\W)/$1$main::rTypes{$k}$2/g;
	}
	return $ln;
}

# Initialize some empty variables
my $nextStatement = ''; # Will hold the CREATE TABLE statement
my $extra = '';         # Will holld addl statements like CREATE INDEX/TRIGGER/etc
my $tableName = '';     # Tablename for use in addl statements

# Write the opening commentline to the output
print "-- Oracle SQL script created by $main::thisScript, v$main::thisVersion\n";

# Read the input line by line
while (my $line = <>) {
	chomp($line);

	# These statements and commentlines will be ignored
	if ($line =~ /^DROP/
		|| $line =~ /^\s*CREATE\s+SCHEMA/
		|| $line =~ /^--/
		|| ($line =~ /^\s*SET/ && $line =~ /\@/)
		|| $line =~ /^\s*USE/) {
		next;
	}

	# Extract the tablename
	if ($line =~ s/(CREATE\s+TABLE(.*?)\`$main::mysqlScheme\`\.\`(\w+)\`\s*\()/CREATE TABLE $main::oracleQuotes$3$main::oracleQuotes ( /) {
		$tableName = $3;
	}
	
	# When creating a view; drop the placeholder table
	if ($line =~ /CREATE\s+(OR\s+REPLACE\s+)?VIEW\s+\`$main::mysqlScheme\`\.\`(\w+)\`\s*/) {
		print "DROP TABLE $main::oracleQuotes$2$main::oracleQuotes;\n";
	}

	# Remove all COMMENT statements
	$line =~ s/COMMENT\s*(=\s*)?'.*?'//g; # TODO Check for escaped single quotes
	
	# Check for anything between backticks an truncate names > 30 chars
	if ($line =~ /`(\w+?)`/) {
		my $_id = $1;
		if (length($_id) > 30) {
			my $_trunc = substr($_id, 0, 30);
			$line =~ s/`$_id`/`$_trunc`/;
		}
	}

	# If there's an 'INDEX' line, remove it, extracting the
	# name of the index, column(s) and check for UNIQUE.
	# Then, create an additional statement ouside the tabledefinition
	if ($line =~ s/\s+(UNIQUE)?\s+INDEX\s+`(\w*?)`\s+(\(.*?\))\s*,?//) {
		$extra .= addIndex($tableName, $2, $3, ($1 ne ''));
	}

	# Check if a column is being defined on this line
	if ($line =~ /^\s*`(\w+?)`\s+/) {

		# Save the columnname
		my $columnName = $1;

		# Remove backticks
		$line =~ s/`$columnName`/$main::oracleQuotes$columnName$main::oracleQuotes/;

		# If this is an Auto Increment, remove the NOT NULL and
		# AUTO_INCREMENT idents and generate the sequence + trigger
		# (NOT NULL is not allowed in Oracle since the trigger
		# is fired after the insert)
		if ($line =~ /AUTO_INCREMENT/) {
			$extra .= addAutoInc($tableName, $columnName);
			$line =~ s/NOT\s+NULL//;
			$line =~ s/AUTO_INCREMENT//;
		}

		# If this line has a default value, it cannot have NOT NULL
		if ($line =~ /DEFAULT/) {
			$line =~ s/NOT\s+NULL//;
		}

		# Replace ENUM by VARCHAR2() and create a constraint
		# with the values allowed
		if ($line =~ /ENUM\s*\((.*?)\)/) {
			my $size = 0; # Will be filled by addConstraint()
			$extra .= addConstraint($tableName, $columnName, $1, \$size);
			$line =~ s/ENUM\s*\(.*?\)/VARCHAR2($size)/;
		}
		# TODO: SET()

		# Check for 'NULL' not being 'NOT NULL' or 'DEFAULT NULL'
		# Since Perl regexp doesn't support variable length backreference,
		# we must do this in 2 steps.
		if ($line =~ /\s+(([A-Z0-9\(\)]*?)\s+NULL)/) {
			if ($2 ne 'NOT' && $2 ne 'DEFAULT') {
				$line =~ s/NULL//;
			}
		}

		# Replace the variable types
		$line = replaceTypes($line);
	}

	# Replace the ENGINE specification by a tablespace
	$line =~ s/ENGINE\s+=\s+\w+,?/TABLESPACE $main::tblSpace/;

	# Remove the unsupported foreign key constraints
	$line =~ s/ON\s+UPDATE\s+[\w\s]+(\W)/$1/;
	$line =~ s/ON\s+DELETE\s+(NO\s+ACTION|RESTRICT)//;

	# Remove all backticks, or replace with quotes if so specified
	$line =~ s/`/$main::oracleQuotes/g;

	# Remove the scheme name from the foreign key constraints (REFERENCES [...])
	$line =~ s/$main::oracleQuotes$main::mysqlScheme$main::oracleQuotes\.//;

	# Some cleanup
	$line =~ s/\s+/ /g;
	$line =~ s/\s+$//g;
	$line =~ s/ ,/,/g;
	$line =~ s/^\s+(\W)/$1/;

	# If this line is not empty, add it to the current statement
	if ($line ne '') {
		$nextStatement .= "\n" . $line;
	}

	# When we've got the termination character at the end of the statement,
	# write all we did to the output and reset all values.
	if ($nextStatement =~ /;\s*$/) {
		$nextStatement =~ s/,(\s*\))/$1/g;
		print "\n" . $nextStatement . "\n";
		$extra =~ s/`/$main::oracleQuotes/g;
		print $extra;
		$extra = '';
		$tableName = '';
		$nextStatement = '';
	}
}

print "quit;\n";
